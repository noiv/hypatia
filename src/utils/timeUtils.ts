/**
 * Time Utilities - UTC Only
 *
 * CRITICAL RULES:
 * 1. ALL internal time operations use UTC
 * 2. Local timezone is ONLY for display (formatters in separate file)
 * 3. Never use: getHours(), setHours(), getDate(), setDate(), etc.
 * 4. Always use: getUTCHours(), setUTCHours(), getUTCDate(), setUTCDate()
 * 5. Layers should NEVER call "new Date()" - time comes from app/bootstrap
 *
 * This is the SINGLE SOURCE OF TRUTH for all time calculations.
 */

import type { TimeStep } from '../config/types';

// ============================================================================
// Data Window Calculations (UTC)
// ============================================================================

/**
 * Calculate data window range centered at currentTime
 *
 * @param currentTime - Center time (UTC)
 * @param maxRangeDays - Window size in days
 * @returns { startTime, endTime } - Window boundaries (UTC)
 *
 * Example: currentTime = 2025-11-09 12:00 UTC, maxRangeDays = 15
 * - daysBack = floor(15/2) = 7
 * - startTime = 2025-11-02 00:00 UTC
 * - endTime = 2025-11-17 00:00 UTC (15 days after start)
 */
export function calculateDataWindow(
  currentTime: Date,
  maxRangeDays: number
): { startTime: Date; endTime: Date } {
  const daysBack = Math.floor(maxRangeDays / 2);

  const startTime = new Date(currentTime);
  startTime.setUTCDate(startTime.getUTCDate() - daysBack);
  startTime.setUTCHours(0, 0, 0, 0); // Start at 00z

  const endTime = new Date(startTime);
  endTime.setUTCDate(endTime.getUTCDate() + maxRangeDays);

  return { startTime, endTime };
}

/**
 * Check if time is within data window
 *
 * @param time - Time to check (UTC)
 * @param currentTime - Reference time (UTC)
 * @param maxRangeDays - Window size in days
 * @returns true if time is within [startTime, endTime)
 *
 * Used by sanitizeUrl to validate URL time parameters
 */
export function isWithinDataWindow(
  time: Date,
  currentTime: Date,
  maxRangeDays: number
): boolean {
  const { startTime, endTime } = calculateDataWindow(currentTime, maxRangeDays);
  const timeMs = time.getTime();
  return timeMs >= startTime.getTime() && timeMs < endTime.getTime();
}

/**
 * Clamp time to data window
 *
 * @param time - Time to clamp (UTC)
 * @param currentTime - Reference time (UTC)
 * @param maxRangeDays - Window size in days
 * @returns Clamped time (UTC)
 */
export function clampTimeToDataWindow(
  time: Date,
  currentTime: Date,
  maxRangeDays: number
): Date {
  const { startTime, endTime } = calculateDataWindow(currentTime, maxRangeDays);
  const timeMs = time.getTime();

  return new Date(
    Math.max(startTime.getTime(), Math.min(endTime.getTime(), timeMs))
  );
}

/**
 * Legacy export alias for backward compatibility
 * @deprecated Use clampTimeToDataWindow instead
 */
export function clampTimeToDataRange(_time: Date): Date {
  // This function needs configLoader which we can't import here without circular dependency
  // Callers should migrate to using clampTimeToDataWindow with explicit parameters
  throw new Error('clampTimeToDataRange is deprecated - use clampTimeToDataWindow with explicit parameters');
}

// ============================================================================
// TimeStep Generation (UTC)
// ============================================================================

/**
 * Parse TimeStep to Date (UTC)
 *
 * @param step - TimeStep object
 * @returns Date object in UTC
 *
 * Example: { date: "20251109", cycle: "12z" } → 2025-11-09 12:00:00 UTC
 */
export function parseTimeStep(step: TimeStep): Date {
  const year = parseInt(step.date.slice(0, 4));
  const month = parseInt(step.date.slice(4, 6)) - 1; // Month is 0-indexed
  const day = parseInt(step.date.slice(6, 8));
  const hour = parseInt(step.cycle.slice(0, 2));

  return new Date(Date.UTC(year, month, day, hour, 0, 0, 0));
}

/**
 * Generate timesteps for data window
 *
 * Creates timesteps centered at currentTime ± (maxRangeDays/2)
 * This is the SINGLE SOURCE OF TRUTH for timestep generation.
 * All layers must use the same timesteps generated by bootstrap/app.
 *
 * @param currentTime - Center time (UTC)
 * @param maxRangeDays - Window size in days
 * @param stepHours - Step size in hours (e.g., 6 for 6-hourly data)
 * @param dataBaseUrl - Base URL for data files
 * @param paramName - Parameter name for file paths (e.g., "temp2m", "tprate")
 * @returns Array of TimeStep objects
 *
 * Example: currentTime = 2025-11-09 12:00 UTC, maxRangeDays = 15, stepHours = 6
 * - Generates 60 timesteps (15 days × 4 steps/day)
 * - Range: 2025-11-02 00z to 2025-11-16 18z
 */
export function generateTimeSteps(
  currentTime: Date,
  maxRangeDays: number,
  stepHours: number,
  dataBaseUrl: string,
  paramName: string
): TimeStep[] {
  const steps: TimeStep[] = [];

  const { startTime, endTime } = calculateDataWindow(currentTime, maxRangeDays);

  // Generate timesteps
  const current = new Date(startTime);
  while (current < endTime) {
    const year = current.getUTCFullYear();
    const month = String(current.getUTCMonth() + 1).padStart(2, '0');
    const day = String(current.getUTCDate()).padStart(2, '0');
    const hour = String(current.getUTCHours()).padStart(2, '0');

    const dateStr = `${year}${month}${day}`;
    const cycle = `${hour}z`;
    const filePath = `${dataBaseUrl}/${paramName}/${dateStr}_${cycle}.bin`;

    steps.push({
      date: dateStr,
      cycle,
      filePath
    });

    // Increment by step hours
    current.setUTCHours(current.getUTCHours() + stepHours);
  }

  return steps;
}

// ============================================================================
// Time → Index Conversion (Single Source of Truth)
// ============================================================================

/**
 * Convert Date to fractional timestep index
 *
 * This is the SINGLE SOURCE OF TRUTH for time-to-index conversion.
 * Bootstrap and render MUST use this same function to avoid mismatches.
 *
 * @param currentTime - Time to convert (UTC)
 * @param timeSteps - Array of timesteps (must be sorted chronologically)
 * @returns Fractional index (0.0 to timeSteps.length-1.0)
 *
 * Behavior:
 * - Interpolates between adjacent timesteps when time is between them
 * - Returns integer index when time exactly matches a timestep
 * - Clamps to [0, length-1] if time is outside range (should not happen if sanitizeUrl works)
 *
 * Example: timeSteps = [00z, 06z, 12z, 18z], currentTime = 09:00 UTC
 * - Falls between index 1 (06z) and index 2 (12z)
 * - Elapsed: 3 hours, Total: 6 hours
 * - Returns: 1 + (3/6) = 1.5
 */
export function timeToIndex(currentTime: Date, timeSteps: TimeStep[]): number {
  if (timeSteps.length === 0) {
    console.warn('[timeUtils] timeToIndex: empty timeSteps array');
    return 0;
  }

  const currentMs = currentTime.getTime();

  // Find the two adjacent timesteps
  for (let i = 0; i < timeSteps.length - 1; i++) {
    const step1 = parseTimeStep(timeSteps[i]!);
    const step2 = parseTimeStep(timeSteps[i + 1]!);

    if (currentMs >= step1.getTime() && currentMs <= step2.getTime()) {
      // Interpolate between i and i+1
      const total = step2.getTime() - step1.getTime();
      const elapsed = currentMs - step1.getTime();
      return i + elapsed / total;
    }
  }

  // Out of range - this should NOT happen if sanitizeUrl is working correctly
  const firstStep = timeSteps[0];
  if (firstStep && currentMs < parseTimeStep(firstStep).getTime()) {
    console.warn(
      '[timeUtils] timeToIndex: time before first timestep (clamping to 0)',
      { currentTime, firstStep }
    );
    return 0;
  }

  console.warn(
    '[timeUtils] timeToIndex: time after last timestep (clamping to length-1)',
    { currentTime, lastStep: timeSteps[timeSteps.length - 1] }
  );
  return timeSteps.length - 1;
}

/**
 * Calculate adjacent indices for progressive loading
 *
 * Returns indices [current-1, current, current+1] filtered to valid range.
 * Used by LayerCacheControl to determine "critical" timesteps to load first.
 *
 * @param currentTime - Time to find adjacent indices for (UTC)
 * @param timeSteps - Array of timesteps
 * @returns Array of indices (1-3 elements depending on boundaries)
 *
 * Example: timeToIndex returns 30.5 (between index 30 and 31)
 * - currentIndex = floor(30.5) = 30
 * - Returns: [29, 30, 31] (if all within bounds)
 */
export function getAdjacentIndices(
  currentTime: Date,
  timeSteps: TimeStep[]
): number[] {
  const fractionalIndex = timeToIndex(currentTime, timeSteps);
  const currentIndex = Math.floor(fractionalIndex);

  const adjacentIndices = [
    currentIndex - 1,
    currentIndex,
    currentIndex + 1
  ].filter(i => i >= 0 && i < timeSteps.length);

  return adjacentIndices;
}

// ============================================================================
// Time Manipulation (UTC-only)
// ============================================================================

/**
 * Add hours to time (UTC)
 *
 * @param time - Base time (UTC)
 * @param hours - Hours to add (can be negative)
 * @returns New Date object (UTC)
 */
export function addHours(time: Date, hours: number): Date {
  return new Date(time.getTime() + hours * 3600000);
}

/**
 * Add days to time (UTC)
 *
 * @param time - Base time (UTC)
 * @param days - Days to add (can be negative)
 * @returns New Date object (UTC)
 */
export function addDays(time: Date, days: number): Date {
  const result = new Date(time);
  result.setUTCDate(result.getUTCDate() + days);
  return result;
}

/**
 * Round to next/previous hour mark (UTC)
 *
 * @param time - Time to round (UTC)
 * @param direction - 1 for next hour, -1 for previous hour
 * @returns Rounded time (UTC)
 *
 * Example: time = 2025-11-09 12:34:56 UTC
 * - direction = 1 → 2025-11-09 13:00:00 UTC
 * - direction = -1 → 2025-11-09 12:00:00 UTC
 *
 * Special case: if already on hour mark (12:00:00), jumps to next/prev hour
 */
export function roundToHour(time: Date, direction: 1 | -1): Date {
  const minutes = time.getUTCMinutes();
  const seconds = time.getUTCSeconds();
  const milliseconds = time.getUTCMilliseconds();

  if (direction > 0) {
    // Forward: go to next full hour
    if (minutes === 0 && seconds === 0 && milliseconds === 0) {
      // Already on full hour, go to next hour
      return addHours(time, 1);
    } else {
      // Round up to next hour
      const result = new Date(time);
      result.setUTCHours(result.getUTCHours() + 1, 0, 0, 0);
      return result;
    }
  } else {
    // Backward: go to previous full hour
    if (minutes === 0 && seconds === 0 && milliseconds === 0) {
      // Already on full hour, go to previous hour
      return addHours(time, -1);
    } else {
      // Round down to current hour
      const result = new Date(time);
      result.setUTCHours(result.getUTCHours(), 0, 0, 0);
      return result;
    }
  }
}

/**
 * Round to next/previous 10-minute mark (UTC)
 *
 * @param time - Time to round (UTC)
 * @param direction - 1 for next mark, -1 for previous mark
 * @returns Rounded time (UTC)
 *
 * Example: time = 2025-11-09 12:34:56 UTC
 * - direction = 1 → 2025-11-09 12:40:00 UTC
 * - direction = -1 → 2025-11-09 12:30:00 UTC
 *
 * Special case: if already on 10-minute mark, jumps to next/prev mark
 */
export function roundToTenMinutes(time: Date, direction: 1 | -1): Date {
  const minutes = time.getUTCMinutes();
  const seconds = time.getUTCSeconds();
  const milliseconds = time.getUTCMilliseconds();

  // Calculate how many minutes to next 10-minute mark
  const currentMinuteInCycle = minutes % 10;
  let minutesToAdd: number;

  if (direction > 0) {
    // Forward: go to next 10-minute mark
    minutesToAdd =
      currentMinuteInCycle === 0 && seconds === 0 && milliseconds === 0
        ? 10 // Already on mark, go to next
        : 10 - currentMinuteInCycle;
  } else {
    // Backward: go to previous 10-minute mark
    minutesToAdd =
      currentMinuteInCycle === 0 && seconds === 0 && milliseconds === 0
        ? -10 // Already on mark, go to previous
        : -currentMinuteInCycle;
  }

  const result = new Date(time);
  result.setUTCMinutes(minutes + minutesToAdd, 0, 0);
  return result;
}

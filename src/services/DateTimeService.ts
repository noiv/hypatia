/**
 * DateTime Service
 *
 * Centralized service for all date/time operations in the application.
 * Consolidates functionality from utils/timeUtils.ts, utils/time.ts, and services/TimeService.ts.
 *
 * CRITICAL RULES:
 * 1. ALL internal time operations use UTC
 * 2. Local timezone is ONLY for display (formatters)
 * 3. Never use: getHours(), setHours(), getDate(), setDate(), etc.
 * 4. Always use: getUTCHours(), setUTCHours(), getUTCDate(), setUTCDate()
 *
 * This is the SINGLE SOURCE OF TRUTH for all time calculations.
 */

import type { TimeStep } from '../config/types'
import type { ConfigService } from './ConfigService'

export class DateTimeService {
  private maxRangeDays: number

  constructor(configService: ConfigService) {
    this.maxRangeDays = configService.getHypatiaConfig().data.maxRangeDays
  }

  // ============================================================================
  // Data Window Calculations (UTC)
  // ============================================================================

  /**
   * Calculate data window range centered at currentTime
   *
   * @param currentTime - Center time (UTC)
   * @returns { startTime, endTime } - Window boundaries (UTC)
   *
   * Example: currentTime = 2025-11-09 12:00 UTC, maxRangeDays = 15
   * - daysBack = floor(15/2) = 7
   * - startTime = 2025-11-02 00:00 UTC
   * - endTime = 2025-11-17 00:00 UTC (15 days after start)
   */
  calculateDataWindow(currentTime: Date): { startTime: Date; endTime: Date } {
    const daysBack = Math.floor(this.maxRangeDays / 2)

    const startTime = new Date(currentTime)
    startTime.setUTCDate(startTime.getUTCDate() - daysBack)
    startTime.setUTCHours(0, 0, 0, 0) // Start at 00z

    const endTime = new Date(startTime)
    endTime.setUTCDate(endTime.getUTCDate() + this.maxRangeDays)

    return { startTime, endTime }
  }

  /**
   * Calculate slider bounds (data window adjusted for UI)
   * Ends 6 hours earlier than data window to align with last timestep (18z)
   */
  calculateSliderBounds(currentTime: Date): { startTime: Date; endTime: Date } {
    const { startTime, endTime } = this.calculateDataWindow(currentTime)

    // Adjust end time to 18z of last day (last data timestep)
    endTime.setUTCHours(endTime.getUTCHours() - 6)

    return { startTime, endTime }
  }

  /**
   * Check if time is within data window
   *
   * @param time - Time to check (UTC)
   * @param currentTime - Reference time (UTC)
   * @returns true if time is within [startTime, endTime)
   */
  isWithinDataWindow(time: Date, currentTime: Date): boolean {
    const { startTime, endTime } = this.calculateDataWindow(currentTime)
    const timeMs = time.getTime()
    return timeMs >= startTime.getTime() && timeMs < endTime.getTime()
  }

  /**
   * Clamp time to data window
   *
   * @param time - Time to clamp (UTC)
   * @param currentTime - Reference time (UTC)
   * @returns Clamped time (UTC)
   */
  clampToDataWindow(time: Date, currentTime: Date): Date {
    const { startTime, endTime } = this.calculateDataWindow(currentTime)
    const timeMs = time.getTime()

    return new Date(Math.max(startTime.getTime(), Math.min(endTime.getTime(), timeMs)))
  }

  /**
   * Clamp time to fixed bounds (for UI time controls)
   *
   * @param time - Time to clamp
   * @param startTime - Fixed start bound
   * @param endTime - Fixed end bound
   * @returns Clamped time
   */
  clampToFixedBounds(time: Date, startTime: Date, endTime: Date): Date {
    const timeMs = time.getTime()
    return new Date(Math.max(startTime.getTime(), Math.min(endTime.getTime(), timeMs)))
  }

  // ============================================================================
  // TimeStep Generation (UTC)
  // ============================================================================

  /**
   * Parse TimeStep to Date (UTC)
   *
   * @param step - TimeStep object
   * @returns Date object in UTC
   *
   * Example: { date: "20251109", cycle: "12z" } → 2025-11-09 12:00:00 UTC
   */
  parseTimeStep(step: TimeStep): Date {
    const year = parseInt(step.date.slice(0, 4))
    const month = parseInt(step.date.slice(4, 6)) - 1 // Month is 0-indexed
    const day = parseInt(step.date.slice(6, 8))
    const hour = parseInt(step.cycle.slice(0, 2))

    return new Date(Date.UTC(year, month, day, hour, 0, 0, 0))
  }

  /**
   * Generate timesteps for data window
   *
   * Creates timesteps centered at currentTime ± (maxRangeDays/2)
   * This is the SINGLE SOURCE OF TRUTH for timestep generation.
   * All layers must use the same timesteps generated by bootstrap/app.
   *
   * File paths are NOT included - use UrlBuilder to construct URLs when needed.
   * This keeps DateTimeService focused on time calculations only.
   *
   * @param currentTime - Center time (UTC)
   * @param stepHours - Step size in hours (e.g., 6 for 6-hourly data)
   * @returns Array of TimeStep objects (date + cycle only)
   *
   * Example: currentTime = 2025-11-09 12:00 UTC, maxRangeDays = 15, stepHours = 6
   * - Generates 60 timesteps (15 days × 4 steps/day)
   * - Range: 2025-11-02 00z to 2025-11-16 18z
   * - Returns: [{ date: "20251102", cycle: "00z" }, ...]
   */
  generateTimeSteps(currentTime: Date, stepHours: number): TimeStep[] {
    const steps: TimeStep[] = []

    const { startTime, endTime } = this.calculateDataWindow(currentTime)

    // Generate timesteps
    const current = new Date(startTime)
    while (current < endTime) {
      const year = current.getUTCFullYear()
      const month = String(current.getUTCMonth() + 1).padStart(2, '0')
      const day = String(current.getUTCDate()).padStart(2, '0')
      const hour = String(current.getUTCHours()).padStart(2, '0')

      const dateStr = `${year}${month}${day}`
      const cycle = `${hour}z`

      steps.push({
        date: dateStr,
        cycle,
      })

      // Increment by step hours
      current.setUTCHours(current.getUTCHours() + stepHours)
    }

    return steps
  }

  // ============================================================================
  // Time → Index Conversion (Single Source of Truth)
  // ============================================================================

  /**
   * Convert Date to fractional timestep index
   *
   * This is the SINGLE SOURCE OF TRUTH for time-to-index conversion.
   * Bootstrap and render MUST use this same function to avoid mismatches.
   *
   * @param currentTime - Time to convert (UTC)
   * @param timeSteps - Array of timesteps (must be sorted chronologically)
   * @returns Fractional index (0.0 to timeSteps.length-1.0)
   *
   * Behavior:
   * - Interpolates between adjacent timesteps when time is between them
   * - Returns integer index when time exactly matches a timestep
   * - Clamps to [0, length-1] if time is outside range
   *
   * Example: timeSteps = [00z, 06z, 12z, 18z], currentTime = 09:00 UTC
   * - Falls between index 1 (06z) and index 2 (12z)
   * - Elapsed: 3 hours, Total: 6 hours
   * - Returns: 1 + (3/6) = 1.5
   */
  timeToIndex(currentTime: Date, timeSteps: TimeStep[]): number {
    if (timeSteps.length === 0) {
      console.warn('[DateTimeService] timeToIndex: empty timeSteps array')
      return 0
    }

    const currentMs = currentTime.getTime()

    // Find the two adjacent timesteps
    for (let i = 0; i < timeSteps.length - 1; i++) {
      const step1 = this.parseTimeStep(timeSteps[i]!)
      const step2 = this.parseTimeStep(timeSteps[i + 1]!)

      if (currentMs >= step1.getTime() && currentMs <= step2.getTime()) {
        // Interpolate between i and i+1
        const total = step2.getTime() - step1.getTime()
        const elapsed = currentMs - step1.getTime()
        return i + elapsed / total
      }
    }

    // Out of range - clamp to valid range
    const firstStep = timeSteps[0]
    if (firstStep && currentMs < this.parseTimeStep(firstStep).getTime()) {
      console.warn(
        '[DateTimeService] timeToIndex: time before first timestep (clamping to 0)',
        { currentTime, firstStep }
      )
      return 0
    }

    console.warn(
      '[DateTimeService] timeToIndex: time after last timestep (clamping to length-1)',
      { currentTime, lastStep: timeSteps[timeSteps.length - 1] }
    )
    return timeSteps.length - 1
  }

  /**
   * Alias for timeToIndex for consistency with other services
   */
  findTimeIndex(currentTime: Date, timeSteps: TimeStep[]): number {
    return this.timeToIndex(currentTime, timeSteps)
  }

  /**
   * Convert fractional index back to Date
   *
   * @param index - Fractional index (0.0 to timeSteps.length-1.0)
   * @param timeSteps - Array of timesteps
   * @returns Date object (UTC)
   */
  indexToTime(index: number, timeSteps: TimeStep[]): Date {
    if (timeSteps.length === 0) {
      console.warn('[DateTimeService] indexToTime: empty timeSteps array')
      return new Date()
    }

    const floorIndex = Math.floor(index)
    const fraction = index - floorIndex

    // Clamp to valid range
    const clampedFloor = Math.max(0, Math.min(timeSteps.length - 1, floorIndex))

    if (fraction === 0 || clampedFloor === timeSteps.length - 1) {
      // Exactly on a timestep, or at the end
      return this.parseTimeStep(timeSteps[clampedFloor]!)
    }

    // Interpolate between floor and ceil
    const time1 = this.parseTimeStep(timeSteps[clampedFloor]!)
    const time2 = this.parseTimeStep(timeSteps[clampedFloor + 1]!)
    const interpolatedMs = time1.getTime() + fraction * (time2.getTime() - time1.getTime())

    return new Date(interpolatedMs)
  }

  /**
   * Calculate adjacent indices for progressive loading
   *
   * Returns floor and ceil indices needed for temporal interpolation.
   * Used by download services to determine "critical" timesteps to load first.
   *
   * @param currentTime - Time to find adjacent indices for (UTC)
   * @param timeSteps - Array of timesteps
   * @returns Array of indices [floor, ceil] for interpolation
   *
   * Example: timeToIndex returns 30.5 (between index 30 and 31)
   * - Returns: [30, 31]
   *
   * Edge case: If fractionalIndex is exactly on a timestamp (e.g., 30.0)
   * - Returns: [30, 30] (same index for both floor and ceil)
   */
  getAdjacentIndices(currentTime: Date, timeSteps: TimeStep[]): number[] {
    const fractionalIndex = this.timeToIndex(currentTime, timeSteps)
    const floorIndex = Math.floor(fractionalIndex)
    const ceilIndex = Math.ceil(fractionalIndex)

    // If exactly on a timestamp, both floor and ceil are the same
    if (floorIndex === ceilIndex) {
      return [floorIndex]
    }

    // Otherwise return both for interpolation
    return [floorIndex, ceilIndex]
  }

  // ============================================================================
  // Time Manipulation (UTC-only)
  // ============================================================================

  /**
   * Add hours to time (UTC)
   *
   * @param time - Base time (UTC)
   * @param hours - Hours to add (can be negative)
   * @returns New Date object (UTC)
   */
  addHours(time: Date, hours: number): Date {
    return new Date(time.getTime() + hours * 3600000)
  }

  /**
   * Add days to time (UTC)
   *
   * @param time - Base time (UTC)
   * @param days - Days to add (can be negative)
   * @returns New Date object (UTC)
   */
  addDays(time: Date, days: number): Date {
    const result = new Date(time)
    result.setUTCDate(result.getUTCDate() + days)
    return result
  }

  /**
   * Round to next/previous hour mark (UTC)
   *
   * @param time - Time to round (UTC)
   * @param direction - 1 for next hour, -1 for previous hour
   * @returns Rounded time (UTC)
   */
  roundToHour(time: Date, direction: 1 | -1): Date {
    const minutes = time.getUTCMinutes()
    const seconds = time.getUTCSeconds()
    const milliseconds = time.getUTCMilliseconds()

    if (direction > 0) {
      // Forward: go to next full hour
      if (minutes === 0 && seconds === 0 && milliseconds === 0) {
        return this.addHours(time, 1)
      } else {
        const result = new Date(time)
        result.setUTCHours(result.getUTCHours() + 1, 0, 0, 0)
        return result
      }
    } else {
      // Backward: go to previous full hour
      if (minutes === 0 && seconds === 0 && milliseconds === 0) {
        return this.addHours(time, -1)
      } else {
        const result = new Date(time)
        result.setUTCHours(result.getUTCHours(), 0, 0, 0)
        return result
      }
    }
  }

  /**
   * Round to next/previous 10-minute mark (UTC)
   *
   * @param time - Time to round (UTC)
   * @param direction - 1 for next mark, -1 for previous mark
   * @returns Rounded time (UTC)
   */
  roundToTenMinutes(time: Date, direction: 1 | -1): Date {
    const minutes = time.getUTCMinutes()
    const seconds = time.getUTCSeconds()
    const milliseconds = time.getUTCMilliseconds()

    const currentMinuteInCycle = minutes % 10
    let minutesToAdd: number

    if (direction > 0) {
      minutesToAdd =
        currentMinuteInCycle === 0 && seconds === 0 && milliseconds === 0
          ? 10 // Already on mark, go to next
          : 10 - currentMinuteInCycle
    } else {
      minutesToAdd =
        currentMinuteInCycle === 0 && seconds === 0 && milliseconds === 0
          ? -10 // Already on mark, go to previous
          : -currentMinuteInCycle
    }

    const result = new Date(time)
    result.setUTCMinutes(minutes + minutesToAdd, 0, 0)
    return result
  }

  // ============================================================================
  // Formatting (Display Only - Uses Local Timezone)
  // ============================================================================

  /**
   * Format date for display
   *
   * @param date - Date to format
   * @returns Formatted string in local timezone
   */
  formatDateTime(date: Date): string {
    return date.toLocaleString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false,
    })
  }

  /**
   * Format time for display in header
   *
   * @param date - Date to format
   * @returns Object with local and UTC formatted strings
   */
  formatTimeForHeader(date: Date): { local: string; utc: string } {
    return {
      local: date.toLocaleString('en-US', {
        year: 'numeric',
        month: 'short',
        day: 'numeric',
        hour: '2-digit',
        minute: '2-digit',
        hour12: false,
      }),
      utc: date.toISOString().replace('T', ' ').substring(0, 19) + ' UTC',
    }
  }

  /**
   * Get timezone information (short and long format)
   *
   * @returns Object with short abbreviation and long name
   */
  getTimezoneInfo(): { short: string; long: string } {
    const date = new Date()

    // Get short format (e.g., "PST" or "GMT+1")
    const shortFormatted = date.toLocaleTimeString('en-US', {
      timeZoneName: 'short',
      hour: 'numeric',
    })
    const short = shortFormatted.split(' ').pop() || ''

    // Get long format (e.g., "Pacific Standard Time")
    const longFormatted = date.toLocaleTimeString('en-US', {
      timeZoneName: 'long',
    })
    const longMatch = longFormatted.match(/\d{1,2}:\d{2}:\d{2}\s+[AP]M\s+(.+)/)
    const long = longMatch?.[1] || ''

    return { short, long }
  }

  /**
   * Get timestep filename components
   *
   * @param date - Date to convert
   * @returns Object with date, cycle, and forecast strings
   */
  getTimestepInfo(date: Date): {
    date: string
    cycle: string
    forecast: string
  } {
    const dateStr = date.toISOString().slice(0, 10).replace(/-/g, '')
    const hour = date.getUTCHours()

    // Determine which 6-hour cycle this belongs to
    const cycleHour = Math.floor(hour / 6) * 6
    const cycle = `${cycleHour.toString().padStart(2, '0')}z`

    // Forecast offset from cycle start
    const forecastHours = hour - cycleHour
    const forecast = `${forecastHours}h`

    return { date: dateStr, cycle, forecast }
  }

  // ============================================================================
  // Current Time Fetching
  // ============================================================================

  /**
   * Get current time from time server (if enabled) or local browser time
   *
   * @param useTimeServer - Whether to fetch from time server
   * @returns Current time (UTC)
   */
  async getCurrentTime(useTimeServer: boolean = false): Promise<Date> {
    if (!useTimeServer) {
      const localTime = new Date()
      console.log('[DateTimeService] Using browser time:', localTime.toISOString())
      return localTime
    }

    // Fetch from time server
    try {
      console.log('[DateTimeService] Fetching current time from time server...')

      const response = await fetch('https://timeapi.io/api/Time/current/zone?timeZone=UTC', {
        signal: AbortSignal.timeout(5000),
      })

      if (!response.ok) {
        throw new Error(`Time server returned ${response.status}`)
      }

      const data = await response.json()
      const serverTime = new Date(data.dateTime)

      console.log(`[DateTimeService] Time server: ${serverTime.toISOString()}`)
      console.log(`[DateTimeService] Timezone: ${data.timeZone}`)

      return serverTime
    } catch (error) {
      console.warn('[DateTimeService] Failed to fetch time from server, using local time')
      console.warn(
        `[DateTimeService] Error: ${error instanceof Error ? error.message : 'Unknown error'}`
      )

      const localTime = new Date()
      console.log(`[DateTimeService] Using local time: ${localTime.toISOString()}`)
      return localTime
    }
  }
}
